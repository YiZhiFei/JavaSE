/*
   关于Java中的整数型
     byte
	 short
	 int
	 long
*/
public class DataTypeTest05
{
	public static void main(String[] args){

		//100L是long类型字面值 
		//x是long类型变量
		//不存在类型转换，直接赋值
		long x = 100L;

		//x变量是long类型，8个字节
		//y变量是int类型，4个字节
		//以下程序可以编译通过吗？
		//编译错误，大容量不能直接赋值给小容量
		int y = x;

		//大容量转换成小容量，需要进行强制类型转换
		//强制类型转换需要加“强制类型转换符”
		//加上强制类型转换符之后编译通过了，但是运行阶段可能损失精度。
		//所以强制类型转换谨慎使用，因为损失精度之后可能损失很严重

		//强转原理：
		   //原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
		   //强转之后的数据：00000000 00000000 00000000 01100100
		   //将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】
		int y = (int)x;
		System.out.println(y);

		   //原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		   //强转之后的数据：10000000 00000000 00000000 00000000
		   //10000000 00000000 00000000 00000000目前存储在计算机内部
		   //计算机存储数据都是采用补码的形式存储
		   //所以10000000 00000000 00000000 00000000现在是一个不嘛形式
		   //将以上的补码转换到原码就是最终结果
		   long k = 2147483648L;
		   int e = (int)k;
		   System.out.println(e);//损失精度严重，结果是负数【-2147483648】

		   //分析以下程序是否可以编译通过？
		   //依据目前所学内容，以下程序是无法编译通过的
		   //理由：50是int类型的字面值，b是byte类型的变量，显然是大容量int转换成小容量byte
		   //大容量转换成小容量是需要添加强制类型转换符的，以下程序没有添加强制符号，所以编译报错。
		   //但是，在实际编译的时候，以下代码编译通过了，这说明：在Java语言当中，当一个整数型字面值
		   //没有超出byte类型取值范围的话，该字面值可以直接赋值给byte类型的变量。
		   byte b = 50;//可以

		   byte c = 127;//可以

		   //编译报错：128这个int类型的字面值已经超出了byte类型的取值范围，
		   //不能直接赋值给byte类型的变量
		   //byte b1 = 128;
		   
		   //纠正错误，需要使用强制类型转换符
		   //但是一定会损失精度
		   //原始数据：00000000 00000000 00000000 10000000
		   //强转之后：10000000【这是存储在计算机内部的，这是一个补码，它的原码是什么？】
		   byte b1 = (byte)128;//-128 为什么它明明byte超出了还是转成byte？
		   //弱智问题 因为130此时是个int字面值，我想输出的时候是在byte范围内，所以我把它强制
           //转换为byte，print出来的范围是在byte内
		   //比如 byte c1 = (byte)130  输出的结果是-126（130-256）这个结果是在byte取值范围内的。
		   System.out.ptintln(b1);
		   
/*
           原码转补码
		   正数变补码，不变
		   负数变补码，将其对应正数二进制表示所有位取反后加一


		  补码：10000000
		  原码：先减1 01111111 -再反位 10000000 -原码-128
		  */

		  //short = 32767 //通过
		  //short s1 = 32768 //编译报错

		  //65535是int类型，4个字节
		  //cc是char类型，2个字节
		  //按照以前所学知识点来说，以下程序是编译报错的
		  char cc = 65535

/*
    当一个证书字面值没有超出byte,short,char的取值范围，
	这个字面值可以直接赋值给byte,short,char类型的变量。
	这种机制SUN允许了，目的是为了方便程序员的编程。

*/
			  

	}
}